[
  {
    "schema": "public",
    "tabela": "caixas",
    "trigger_nome": "trigger_verificar_caixa_aberto",
    "funcao": "verificar_caixa_aberto",
    "definicao_completa": "CREATE TRIGGER trigger_verificar_caixa_aberto BEFORE INSERT OR UPDATE ON public.caixas FOR EACH ROW EXECUTE FUNCTION verificar_caixa_aberto()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.verificar_caixa_aberto()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  IF NEW.status = 'aberto' THEN\r\n    IF EXISTS (\r\n      SELECT 1 FROM caixas \r\n      WHERE loja_id = NEW.loja_id \r\n      AND status = 'aberto' \r\n      AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000'::UUID)\r\n    ) THEN\r\n      RAISE EXCEPTION 'J√É¬° existe um caixa aberto para esta loja';\r\n    END IF;\r\n  END IF;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "clientes",
    "trigger_nome": "trigger_atualizar_clientes",
    "funcao": "atualizar_timestamp_clientes",
    "definicao_completa": "CREATE TRIGGER trigger_atualizar_clientes BEFORE UPDATE ON public.clientes FOR EACH ROW EXECUTE FUNCTION atualizar_timestamp_clientes()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.atualizar_timestamp_clientes()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.atualizado_em = NOW();\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "configuracoes_usuario",
    "trigger_nome": "update_configuracoes_usuario_updated_at",
    "funcao": "update_updated_at_column",
    "definicao_completa": "CREATE TRIGGER update_configuracoes_usuario_updated_at BEFORE UPDATE ON public.configuracoes_usuario FOR EACH ROW EXECUTE FUNCTION update_updated_at_column()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.updated_at = TIMEZONE('utc', NOW());\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "estoque_lojas",
    "trigger_nome": "trigger_atualizar_timestamp_estoque_lojas",
    "funcao": "atualizar_timestamp_estoque_lojas",
    "definicao_completa": "CREATE TRIGGER trigger_atualizar_timestamp_estoque_lojas BEFORE UPDATE ON public.estoque_lojas FOR EACH ROW EXECUTE FUNCTION atualizar_timestamp_estoque_lojas()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.atualizar_timestamp_estoque_lojas()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    NEW.atualizado_em = NOW();\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "estoque_lojas",
    "trigger_nome": "trigger_notificacao_estoque_simples",
    "funcao": "notificar_estoque_simples",
    "definicao_completa": "CREATE TRIGGER trigger_notificacao_estoque_simples AFTER UPDATE OF quantidade ON public.estoque_lojas FOR EACH ROW WHEN ((old.quantidade IS DISTINCT FROM new.quantidade)) EXECUTE FUNCTION notificar_estoque_simples()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.notificar_estoque_simples()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_produto_nome TEXT;\r\n  v_loja_nome TEXT;\r\n  v_titulo TEXT;\r\n  v_mensagem TEXT;\r\n  v_tipo TEXT;\r\n  v_estado_anterior TEXT;\r\n  v_deve_notificar BOOLEAN := FALSE;\r\n  v_novo_estado TEXT;\r\n  v_quantidade_minima INTEGER;\r\nBEGIN\r\n  -- Buscar quantidade_minima do produto\r\n  SELECT p.quantidade_minima INTO v_quantidade_minima\r\n  FROM produtos p\r\n  WHERE p.id = NEW.id_produto;\r\n  \r\n  -- Buscar nomes do produto e loja\r\n  SELECT p.descricao INTO v_produto_nome\r\n  FROM produtos p\r\n  WHERE p.id = NEW.id_produto;\r\n  \r\n  SELECT l.nome INTO v_loja_nome\r\n  FROM lojas l\r\n  WHERE l.id = NEW.id_loja;\r\n  \r\n  -- Buscar estado anterior\r\n  SELECT estado INTO v_estado_anterior\r\n  FROM alertas_estoque_controle\r\n  WHERE produto_id = NEW.id_produto \r\n    AND loja_id = NEW.id_loja;\r\n  \r\n  RAISE NOTICE 'üìä Verificando: produto=%, loja=%, qtd=%, min=%, estado_ant=%', \r\n    v_produto_nome, v_loja_nome, NEW.quantidade, v_quantidade_minima, COALESCE(v_estado_anterior, 'nenhum');\r\n  \r\n  -- ============================================\r\n  -- L√ìGICA DE NOTIFICA√á√ÉO\r\n  -- ============================================\r\n  \r\n  -- Caso 1: ESTOQUE ZERADO\r\n  IF NEW.quantidade = 0 THEN\r\n    IF v_estado_anterior IS NULL OR v_estado_anterior != 'zerado' THEN\r\n      v_tipo := 'estoque_zerado';\r\n      v_titulo := 'Estoque Zerado';\r\n      v_mensagem := 'O produto ' || v_produto_nome || ' est√° com estoque zerado na loja ' || v_loja_nome || '.';\r\n      v_deve_notificar := TRUE;\r\n      RAISE NOTICE 'üî¥ ZERADO: vai notificar';\r\n    ELSE\r\n      RAISE NOTICE '‚ö™ ZERADO: j√° estava zerado';\r\n    END IF;\r\n  \r\n  -- Caso 2: ESTOQUE BAIXO\r\n  ELSIF NEW.quantidade > 0 AND NEW.quantidade <= v_quantidade_minima THEN\r\n    IF v_estado_anterior IS NULL OR v_estado_anterior != 'baixo' THEN\r\n      v_tipo := 'estoque_baixo';\r\n      v_titulo := 'Estoque Baixo';\r\n      v_mensagem := 'O produto ' || v_produto_nome || ' est√° com estoque baixo na loja ' || v_loja_nome || '. Quantidade atual: ' || NEW.quantidade || ' (M√≠nimo: ' || v_quantidade_minima || ')';\r\n      v_deve_notificar := TRUE;\r\n      RAISE NOTICE 'üü° BAIXO: vai notificar';\r\n    ELSE\r\n      RAISE NOTICE '‚ö™ BAIXO: j√° estava baixo';\r\n    END IF;\r\n  \r\n  -- Caso 3: ESTOQUE REPOSTO\r\n  ELSIF NEW.quantidade > v_quantidade_minima THEN\r\n    IF v_estado_anterior = 'baixo' OR v_estado_anterior = 'zerado' THEN\r\n      v_tipo := 'estoque_reposto';\r\n      v_titulo := 'Estoque Reposto';\r\n      v_mensagem := 'O produto ' || v_produto_nome || ' foi reposto na loja ' || v_loja_nome || '. Quantidade atual: ' || NEW.quantidade || ' (M√≠nimo: ' || v_quantidade_minima || ')';\r\n      v_deve_notificar := TRUE;\r\n      RAISE NOTICE 'üü¢ REPOSTO: vai notificar';\r\n    ELSE\r\n      RAISE NOTICE '‚ö™ NORMAL: continua normal';\r\n    END IF;\r\n  END IF;\r\n  \r\n  -- ============================================\r\n  -- CRIAR NOTIFICA√á√ÉO SE NECESS√ÅRIO\r\n  -- ============================================\r\n  \r\n  IF v_deve_notificar THEN\r\n    RAISE NOTICE '‚úÖ Criando notifica√ß√£o: tipo=%', v_tipo;\r\n    \r\n    INSERT INTO notificacoes (\r\n      tipo,\r\n      titulo,\r\n      mensagem,\r\n      produto_id,\r\n      loja_id,\r\n      criado_em\r\n    ) VALUES (\r\n      v_tipo,\r\n      v_titulo,\r\n      v_mensagem,\r\n      NEW.id_produto,\r\n      NEW.id_loja,\r\n      NOW()\r\n    );\r\n    \r\n    RAISE NOTICE 'üì¨ Notifica√ß√£o criada!';\r\n  END IF;\r\n  \r\n  -- ============================================\r\n  -- ATUALIZAR CONTROLE DE ESTADO\r\n  -- ============================================\r\n  \r\n  IF NEW.quantidade = 0 THEN\r\n    v_novo_estado := 'zerado';\r\n  ELSIF NEW.quantidade <= v_quantidade_minima THEN\r\n    v_novo_estado := 'baixo';\r\n  ELSE\r\n    v_novo_estado := 'normal';\r\n  END IF;\r\n  \r\n  INSERT INTO alertas_estoque_controle (\r\n    produto_id,\r\n    loja_id,\r\n    estado,\r\n    quantidade_atual,\r\n    quantidade_minima,\r\n    atualizado_em\r\n  ) VALUES (\r\n    NEW.id_produto,\r\n    NEW.id_loja,\r\n    v_novo_estado,\r\n    NEW.quantidade,\r\n    v_quantidade_minima,\r\n    NOW()\r\n  )\r\n  ON CONFLICT (produto_id, loja_id) \r\n  DO UPDATE SET\r\n    estado = v_novo_estado,\r\n    quantidade_atual = NEW.quantidade,\r\n    quantidade_minima = v_quantidade_minima,\r\n    atualizado_em = NOW();\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "estoque_lojas",
    "trigger_nome": "trigger_registrar_ajuste_manual",
    "funcao": "registrar_historico_ajuste_manual",
    "definicao_completa": "CREATE TRIGGER trigger_registrar_ajuste_manual AFTER UPDATE ON public.estoque_lojas FOR EACH ROW EXECUTE FUNCTION registrar_historico_ajuste_manual()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.registrar_historico_ajuste_manual()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n    v_usuario_id UUID;\r\nBEGIN\r\n    -- Capturar o usu√°rio autenticado\r\n    v_usuario_id := COALESCE(\r\n        NEW.atualizado_por, \r\n        OLD.atualizado_por, \r\n        auth.uid()\r\n    );\r\n\r\n    -- Apenas para UPDATE de quantidade via modal de ajuste manual\r\n    -- Detecta ajuste manual quando atualizado_por √© preenchido\r\n    -- e n√£o existe registro recente no historico (c√≥digo n√£o registrou manualmente)\r\n    IF TG_OP = 'UPDATE' \r\n       AND OLD.quantidade IS DISTINCT FROM NEW.quantidade \r\n       AND NEW.atualizado_por IS NOT NULL THEN\r\n        \r\n        -- Verificar se c√≥digo j√° registrou manualmente\r\n        IF NOT EXISTS(\r\n            SELECT 1 \r\n            FROM historico_estoque \r\n            WHERE id_produto = NEW.id_produto \r\n              AND id_loja = NEW.id_loja\r\n              AND quantidade_nova = NEW.quantidade\r\n              AND criado_em > NOW() - INTERVAL '1 second'\r\n        ) THEN\r\n            -- Registrar ajuste manual\r\n            INSERT INTO historico_estoque (\r\n                id_produto,\r\n                id_loja,\r\n                quantidade,\r\n                quantidade_anterior,\r\n                quantidade_nova,\r\n                usuario_id,\r\n                tipo_movimentacao,\r\n                observacao\r\n            ) VALUES (\r\n                NEW.id_produto,\r\n                NEW.id_loja,\r\n                ABS(NEW.quantidade - OLD.quantidade),\r\n                OLD.quantidade,\r\n                NEW.quantidade,\r\n                v_usuario_id,\r\n                'ajuste',\r\n                'Ajuste manual de estoque'\r\n            );\r\n        END IF;\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "fornecedores",
    "trigger_nome": "trigger_atualizar_timestamp_fornecedores",
    "funcao": "atualizar_timestamp_fornecedores",
    "definicao_completa": "CREATE TRIGGER trigger_atualizar_timestamp_fornecedores BEFORE UPDATE ON public.fornecedores FOR EACH ROW EXECUTE FUNCTION atualizar_timestamp_fornecedores()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.atualizar_timestamp_fornecedores()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    NEW.atualizado_em = NOW();\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "fornecedores",
    "trigger_nome": "trigger_historico_fornecedores",
    "funcao": "registrar_historico_fornecedores",
    "definicao_completa": "CREATE TRIGGER trigger_historico_fornecedores AFTER INSERT OR DELETE OR UPDATE ON public.fornecedores FOR EACH ROW EXECUTE FUNCTION registrar_historico_fornecedores()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.registrar_historico_fornecedores()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    IF (TG_OP = 'DELETE') THEN\r\n        INSERT INTO public.historico_fornecedores (fornecedor_id, operacao, dados_anteriores, usuario_id)\r\n        VALUES (OLD.id, TG_OP, row_to_json(OLD), OLD.atualizado_por);\r\n        RETURN OLD;\r\n    ELSIF (TG_OP = 'UPDATE') THEN\r\n        INSERT INTO public.historico_fornecedores (fornecedor_id, operacao, dados_anteriores, dados_novos, usuario_id)\r\n        VALUES (NEW.id, TG_OP, row_to_json(OLD), row_to_json(NEW), NEW.atualizado_por);\r\n        RETURN NEW;\r\n    ELSIF (TG_OP = 'INSERT') THEN\r\n        INSERT INTO public.historico_fornecedores (fornecedor_id, operacao, dados_novos, usuario_id)\r\n        VALUES (NEW.id, TG_OP, row_to_json(NEW), NEW.criado_por);\r\n        RETURN NEW;\r\n    END IF;\r\n    RETURN NULL;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "itens_devolucao",
    "trigger_nome": "trigger_registrar_devolucao_estoque",
    "funcao": "registrar_devolucao_estoque",
    "definicao_completa": "CREATE TRIGGER trigger_registrar_devolucao_estoque AFTER INSERT ON public.itens_devolucao FOR EACH ROW EXECUTE FUNCTION registrar_devolucao_estoque()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.registrar_devolucao_estoque()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_produto_id UUID;\r\n  v_loja_id INTEGER;\r\n  v_usuario_id UUID;\r\n  v_numero_venda VARCHAR;\r\n  v_quantidade_anterior INTEGER;\r\nBEGIN\r\n  -- Buscar informa√ß√µes do item de venda\r\n  SELECT iv.produto_id\r\n  INTO v_produto_id\r\n  FROM itens_venda iv\r\n  WHERE iv.id = NEW.item_venda_id;\r\n  \r\n  IF v_produto_id IS NULL THEN\r\n    RAISE EXCEPTION 'Produto n√£o encontrado para item_venda_id: %', NEW.item_venda_id;\r\n  END IF;\r\n  \r\n  -- Buscar informa√ß√µes da venda\r\n  SELECT v.loja_id, v.numero_venda\r\n  INTO v_loja_id, v_numero_venda\r\n  FROM vendas v\r\n  JOIN itens_venda iv ON iv.venda_id = v.id\r\n  WHERE iv.id = NEW.item_venda_id;\r\n  \r\n  IF v_loja_id IS NULL THEN\r\n    RAISE EXCEPTION 'Venda n√£o encontrada para item_venda_id: %', NEW.item_venda_id;\r\n  END IF;\r\n  \r\n  -- Buscar usu√°rio que realizou a devolu√ß√£o\r\n  SELECT dv.realizado_por\r\n  INTO v_usuario_id\r\n  FROM devolucoes_venda dv\r\n  WHERE dv.id = NEW.devolucao_id;\r\n  \r\n  -- Buscar quantidade anterior do estoque\r\n  SELECT COALESCE(el.quantidade, 0)\r\n  INTO v_quantidade_anterior\r\n  FROM estoque_lojas el\r\n  WHERE el.id_produto = v_produto_id\r\n  AND el.id_loja = v_loja_id;\r\n  \r\n  -- Se n√£o encontrou, quantidade anterior √© 0\r\n  IF v_quantidade_anterior IS NULL THEN\r\n    v_quantidade_anterior := 0;\r\n  END IF;\r\n  \r\n  -- Atualizar estoque da loja\r\n  INSERT INTO estoque_lojas (id_produto, id_loja, quantidade, atualizado_em, atualizado_por)\r\n  VALUES (v_produto_id, v_loja_id, NEW.quantidade, NOW(), v_usuario_id)\r\n  ON CONFLICT (id_produto, id_loja)\r\n  DO UPDATE SET \r\n    quantidade = estoque_lojas.quantidade + NEW.quantidade,\r\n    atualizado_em = NOW(),\r\n    atualizado_por = v_usuario_id;\r\n  \r\n  -- Registrar no hist√≥rico (CORRIGIDO: Devolucao ao inv√©s de Devolu√ß√£o)\r\n  INSERT INTO historico_estoque (\r\n    id_produto,\r\n    id_loja,\r\n    tipo_movimentacao,\r\n    quantidade,\r\n    quantidade_anterior,\r\n    quantidade_nova,\r\n    motivo,\r\n    usuario_id,\r\n    criado_em\r\n  ) VALUES (\r\n    v_produto_id,\r\n    v_loja_id,\r\n    'devolucao_venda',\r\n    NEW.quantidade,\r\n    v_quantidade_anterior,\r\n    v_quantidade_anterior + NEW.quantidade,\r\n    'Devolucao da venda #' || COALESCE(v_numero_venda, 'N/A') || ' - ' || COALESCE(NEW.motivo, 'Sem motivo'),\r\n    v_usuario_id,\r\n    NOW()\r\n  );\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "itens_venda",
    "trigger_nome": "trigger_baixa_estoque_ao_adicionar_item",
    "funcao": "baixa_estoque_ao_adicionar_item",
    "definicao_completa": "CREATE TRIGGER trigger_baixa_estoque_ao_adicionar_item AFTER INSERT ON public.itens_venda FOR EACH ROW EXECUTE FUNCTION baixa_estoque_ao_adicionar_item()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.baixa_estoque_ao_adicionar_item()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_loja_id INTEGER;\r\n  v_quantidade_atual INTEGER;\r\n  v_cliente_nome TEXT;\r\n  v_vendedor_nome TEXT;\r\n  v_vendedor_id UUID;\r\n  v_venda_numero INTEGER;\r\nBEGIN\r\n  -- Buscar informa√ß√µes da venda\r\n  SELECT v.loja_id, v.numero_venda, v.vendedor_id, c.nome, u.nome\r\n  INTO v_loja_id, v_venda_numero, v_vendedor_id, v_cliente_nome, v_vendedor_nome\r\n  FROM vendas v\r\n  LEFT JOIN clientes c ON c.id = v.cliente_id\r\n  LEFT JOIN usuarios u ON u.id = v.vendedor_id\r\n  WHERE v.id = NEW.venda_id;\r\n  \r\n  -- Buscar quantidade atual no estoque\r\n  SELECT quantidade INTO v_quantidade_atual\r\n  FROM estoque_lojas\r\n  WHERE id_produto = NEW.produto_id \r\n    AND id_loja = v_loja_id;\r\n  \r\n  -- Se n√£o encontrou o estoque, retorna sem fazer nada\r\n  IF v_quantidade_atual IS NULL THEN\r\n    RAISE WARNING 'Produto % n√£o tem estoque na loja %', NEW.produto_id, v_loja_id;\r\n    RETURN NEW;\r\n  END IF;\r\n  \r\n  RAISE NOTICE 'üîµ Iniciando baixa de estoque: produto=%, loja=%, qtd_atual=%, qtd_venda=%', \r\n    NEW.produto_id, v_loja_id, v_quantidade_atual, NEW.quantidade;\r\n  \r\n  -- Atualizar o estoque (REDUZ a quantidade)\r\n  -- IMPORTANTE: preencher atualizado_por faz a trigger gen√©rica ignorar\r\n  UPDATE estoque_lojas\r\n  SET \r\n    quantidade = quantidade - NEW.quantidade,\r\n    atualizado_em = NOW(),\r\n    atualizado_por = v_vendedor_id\r\n  WHERE id_produto = NEW.produto_id \r\n    AND id_loja = v_loja_id;\r\n  \r\n  RAISE NOTICE '‚úÖ Estoque atualizado! Nova quantidade=%', (v_quantidade_atual - NEW.quantidade);\r\n  \r\n  -- Deletar registro gen√©rico se foi criado (ap√≥s o UPDATE)\r\n  DELETE FROM historico_estoque\r\n  WHERE id_produto = NEW.produto_id\r\n    AND id_loja = v_loja_id\r\n    AND observacao = 'Quantidade alterada'\r\n    AND usuario_id = v_vendedor_id\r\n    AND tipo_movimentacao IS NULL\r\n    AND criado_em > NOW() - INTERVAL '1 second';\r\n  \r\n  -- Registrar no hist√≥rico com informa√ß√µes completas da venda\r\n  -- Este √© o √öNICO registro que deve ser criado\r\n  INSERT INTO historico_estoque (\r\n    id_produto,\r\n    id_loja,\r\n    usuario_id,\r\n    quantidade_anterior,\r\n    quantidade_nova,\r\n    quantidade_alterada,\r\n    tipo_movimentacao,\r\n    observacao\r\n  ) VALUES (\r\n    NEW.produto_id,\r\n    v_loja_id,\r\n    v_vendedor_id,\r\n    v_quantidade_atual,\r\n    v_quantidade_atual - NEW.quantidade,\r\n    -NEW.quantidade,\r\n    'venda',\r\n    CASE \r\n      WHEN v_cliente_nome IS NOT NULL THEN\r\n        'Venda #' || COALESCE(v_venda_numero::TEXT, SUBSTRING(NEW.venda_id::TEXT, 1, 8)) || ' - Cliente: ' || v_cliente_nome\r\n      ELSE\r\n        'Venda #' || COALESCE(v_venda_numero::TEXT, SUBSTRING(NEW.venda_id::TEXT, 1, 8))\r\n    END\r\n  );\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "lojas",
    "trigger_nome": "trigger_historico_lojas",
    "funcao": "registrar_historico_lojas",
    "definicao_completa": "CREATE TRIGGER trigger_historico_lojas AFTER INSERT OR DELETE OR UPDATE ON public.lojas FOR EACH ROW EXECUTE FUNCTION registrar_historico_lojas()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.registrar_historico_lojas()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_usuario_id UUID;\r\n    v_dados_antigos JSONB;\r\n    v_dados_novos JSONB;\r\nBEGIN\r\n    -- Tentar obter o usuario_id da vari√°vel de sess√£o primeiro\r\n    BEGIN\r\n        v_usuario_id := current_setting('app.current_user_id', true)::UUID;\r\n        RAISE NOTICE '‚úÖ Usuario ID da sess√£o obtido: %', v_usuario_id;\r\n    EXCEPTION WHEN OTHERS THEN\r\n        -- Se n√£o existir na sess√£o, tentar auth.uid()\r\n        v_usuario_id := auth.uid();\r\n        RAISE NOTICE '‚ö†Ô∏è Usuario ID do auth.uid(): %', v_usuario_id;\r\n    END;\r\n\r\n    -- Log para debug\r\n    IF v_usuario_id IS NULL THEN\r\n        RAISE WARNING '‚ùå usuario_id est√° NULL - nenhum m√©todo funcionou!';\r\n    END IF;\r\n\r\n    -- Preparar os dados conforme a opera√ß√£o\r\n    IF (TG_OP = 'DELETE') THEN\r\n        v_dados_antigos := to_jsonb(OLD);\r\n        v_dados_novos := NULL;\r\n    ELSIF (TG_OP = 'UPDATE') THEN\r\n        v_dados_antigos := to_jsonb(OLD);\r\n        v_dados_novos := to_jsonb(NEW);\r\n    ELSIF (TG_OP = 'INSERT') THEN\r\n        v_dados_antigos := NULL;\r\n        v_dados_novos := to_jsonb(NEW);\r\n    END IF;\r\n\r\n    -- Inserir registro no hist√≥rico\r\n    INSERT INTO historico_lojas (\r\n        loja_id,\r\n        operacao,\r\n        dados_antigos,\r\n        dados_novos,\r\n        usuario_id\r\n    ) VALUES (\r\n        COALESCE(NEW.id, OLD.id),\r\n        TG_OP,\r\n        v_dados_antigos,\r\n        v_dados_novos,\r\n        v_usuario_id  -- Agora permite NULL temporariamente\r\n    );\r\n\r\n    RETURN COALESCE(NEW, OLD);\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "lojas_fotos",
    "trigger_nome": "trigger_atualizar_timestamp_lojas_fotos",
    "funcao": "atualizar_timestamp_lojas_fotos",
    "definicao_completa": "CREATE TRIGGER trigger_atualizar_timestamp_lojas_fotos BEFORE UPDATE ON public.lojas_fotos FOR EACH ROW EXECUTE FUNCTION atualizar_timestamp_lojas_fotos()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.atualizar_timestamp_lojas_fotos()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.atualizado_em = NOW();\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "notificacoes",
    "trigger_nome": "trigger_popular_notificacoes_usuarios",
    "funcao": "popular_notificacoes_usuarios",
    "definicao_completa": "CREATE TRIGGER trigger_popular_notificacoes_usuarios AFTER INSERT ON public.notificacoes FOR EACH ROW EXECUTE FUNCTION popular_notificacoes_usuarios()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.popular_notificacoes_usuarios()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_usuario RECORD;\r\n  v_count INTEGER := 0;\r\nBEGIN\r\n  -- Log para debug\r\n  RAISE NOTICE 'Trigger popular_notificacoes_usuarios disparado para notificacao ID=%', NEW.id;\r\n  \r\n  -- Inserir para todos os usu√°rios ativos\r\n  -- (ajuste o WHERE se quiser apenas admins ou gerentes)\r\n  FOR v_usuario IN \r\n    SELECT id \r\n    FROM usuarios \r\n    WHERE ativo = true\r\n  LOOP\r\n    INSERT INTO notificacoes_usuarios (\r\n      notificacao_id,\r\n      usuario_id,\r\n      lida,\r\n      criado_em\r\n    ) VALUES (\r\n      NEW.id,\r\n      v_usuario.id,\r\n      false,\r\n      NOW()\r\n    );\r\n    \r\n    v_count := v_count + 1;\r\n  END LOOP;\r\n  \r\n  RAISE NOTICE 'Criados % registros em notificacoes_usuarios para notificacao ID=%', v_count, NEW.id;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "ordem_servico",
    "trigger_nome": "trigger_atualizar_os",
    "funcao": "atualizar_timestamp_os",
    "definicao_completa": "CREATE TRIGGER trigger_atualizar_os BEFORE UPDATE ON public.ordem_servico FOR EACH ROW EXECUTE FUNCTION atualizar_timestamp_os()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.atualizar_timestamp_os()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.atualizado_em = NOW();\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "ordem_servico",
    "trigger_nome": "trigger_devolver_pecas_ao_cancelar",
    "funcao": "devolver_pecas_ao_cancelar_os",
    "definicao_completa": "CREATE TRIGGER trigger_devolver_pecas_ao_cancelar AFTER UPDATE OF status ON public.ordem_servico FOR EACH ROW EXECUTE FUNCTION devolver_pecas_ao_cancelar_os()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.devolver_pecas_ao_cancelar_os()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_peca RECORD;\r\n  v_quantidade_anterior INTEGER;\r\n  v_quantidade_nova INTEGER;\r\n  v_contador INTEGER := 0;\r\nBEGIN\r\n  -- Verificar se mudou para cancelado\r\n  IF NEW.status = 'cancelado' AND (OLD.status IS NULL OR OLD.status != 'cancelado') THEN\r\n    \r\n    RAISE NOTICE '=== INICIANDO DEVOLU√á√ÉO PARA OS % ===', NEW.numero_os;\r\n    \r\n    -- Processar cada pe√ßa do estoque desta OS\r\n    FOR v_peca IN \r\n      SELECT \r\n        osp.id,\r\n        osp.id_produto,\r\n        osp.id_loja,\r\n        osp.tipo_produto,\r\n        osp.descricao_peca,\r\n        osp.quantidade,\r\n        osp.estoque_baixado,\r\n        p.descricao as produto_descricao\r\n      FROM ordem_servico_pecas osp\r\n      LEFT JOIN produtos p ON p.id = osp.id_produto\r\n      WHERE osp.id_ordem_servico = NEW.id \r\n        AND osp.tipo_produto = 'estoque'\r\n        AND osp.id_produto IS NOT NULL\r\n        AND osp.id_loja IS NOT NULL\r\n    LOOP\r\n      \r\n      RAISE NOTICE 'Pe√ßa: % (qtd: %) - Baixado: %', \r\n        v_peca.descricao_peca, \r\n        v_peca.quantidade, \r\n        COALESCE(v_peca.estoque_baixado, TRUE);\r\n      \r\n      -- Verificar se estoque foi baixado\r\n      IF COALESCE(v_peca.estoque_baixado, TRUE) = TRUE THEN\r\n        \r\n        -- Buscar quantidade atual do estoque\r\n        SELECT quantidade INTO v_quantidade_anterior\r\n        FROM estoque_lojas\r\n        WHERE id_produto = v_peca.id_produto\r\n          AND id_loja = v_peca.id_loja;\r\n        \r\n        IF v_quantidade_anterior IS NULL THEN\r\n          RAISE NOTICE '  ‚ö†Ô∏è Produto n√£o encontrado no estoque da loja %', v_peca.id_loja;\r\n          CONTINUE;\r\n        END IF;\r\n        \r\n        -- Calcular nova quantidade\r\n        v_quantidade_nova := v_quantidade_anterior + v_peca.quantidade;\r\n        \r\n        RAISE NOTICE '  ‚ÜóÔ∏è Devolvendo: % -> % unidades', v_quantidade_anterior, v_quantidade_nova;\r\n        \r\n        -- Devolver ao estoque\r\n        UPDATE estoque_lojas\r\n        SET quantidade = v_quantidade_nova,\r\n            atualizado_por = NEW.atualizado_por,\r\n            atualizado_em = NOW()\r\n        WHERE id_produto = v_peca.id_produto\r\n          AND id_loja = v_peca.id_loja;\r\n        \r\n        -- Registrar no hist√≥rico (USANDO AS COLUNAS CORRETAS)\r\n        INSERT INTO historico_estoque (\r\n          id_produto,\r\n          id_loja,\r\n          id_ordem_servico,\r\n          tipo_movimentacao,\r\n          quantidade_alterada,\r\n          quantidade_anterior,\r\n          quantidade_nova,\r\n          motivo,\r\n          observacao,\r\n          usuario_id  -- COLUNA CORRETA!\r\n        ) VALUES (\r\n          v_peca.id_produto,\r\n          v_peca.id_loja,\r\n          NEW.id,\r\n          'entrada',\r\n          v_peca.quantidade,\r\n          v_quantidade_anterior,\r\n          v_quantidade_nova,\r\n          'Devolu√ß√£o por cancelamento de OS #' || NEW.numero_os,\r\n          COALESCE(v_peca.produto_descricao, v_peca.descricao_peca),\r\n          NEW.atualizado_por  -- usuario_id\r\n        );\r\n        \r\n        -- Atualizar flag da pe√ßa\r\n        UPDATE ordem_servico_pecas\r\n        SET estoque_baixado = FALSE\r\n        WHERE id = v_peca.id;\r\n        \r\n        v_contador := v_contador + 1;\r\n        RAISE NOTICE '  ‚úÖ Pe√ßa devolvida!';\r\n        \r\n      ELSE\r\n        RAISE NOTICE '  ‚ÑπÔ∏è Pe√ßa j√° foi devolvida anteriormente';\r\n      END IF;\r\n      \r\n    END LOOP;\r\n    \r\n    RAISE NOTICE '=== DEVOLU√á√ÉO CONCLU√çDA: % pe√ßas processadas ===', v_contador;\r\n    \r\n  END IF;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "ordem_servico",
    "trigger_nome": "trigger_historico_os",
    "funcao": "registrar_historico_os",
    "definicao_completa": "CREATE TRIGGER trigger_historico_os AFTER INSERT OR UPDATE ON public.ordem_servico FOR EACH ROW EXECUTE FUNCTION registrar_historico_os()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.registrar_historico_os()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_tipo_evento VARCHAR(50);\r\n  v_descricao TEXT;\r\n  v_usuario_nome VARCHAR(255);\r\nBEGIN\r\n  -- Buscar nome do usu√°rio (admin OU t√©cnico)\r\n  -- Primeiro tenta em usuarios, depois em tecnicos\r\n  SELECT nome INTO v_usuario_nome\r\n  FROM usuarios\r\n  WHERE id = COALESCE(NEW.atualizado_por, NEW.criado_por)\r\n  LIMIT 1;\r\n  \r\n  -- Se n√£o encontrou em usuarios, busca em tecnicos\r\n  IF v_usuario_nome IS NULL THEN\r\n    SELECT nome INTO v_usuario_nome\r\n    FROM tecnicos\r\n    WHERE usuario_id = COALESCE(NEW.atualizado_por, NEW.criado_por)\r\n    LIMIT 1;\r\n  END IF;\r\n  \r\n  -- Se ainda n√£o encontrou, usa identificador gen√©rico\r\n  IF v_usuario_nome IS NULL THEN\r\n    v_usuario_nome := 'Usu√°rio n√£o identificado';\r\n  END IF;\r\n\r\n  IF TG_OP = 'INSERT' THEN\r\n    v_tipo_evento := 'criacao';\r\n    v_descricao := 'Ordem de Servi√ßo criada - OS #' || NEW.numero_os;\r\n    \r\n    INSERT INTO historico_ordem_servico (\r\n      id_ordem_servico,\r\n      tipo_evento,\r\n      status_novo,\r\n      descricao,\r\n      dados_novos,\r\n      criado_por,\r\n      criado_por_nome\r\n    ) VALUES (\r\n      NEW.id,\r\n      v_tipo_evento,\r\n      NEW.status,\r\n      v_descricao,\r\n      to_jsonb(NEW),\r\n      NEW.criado_por,\r\n      v_usuario_nome\r\n    );\r\n    \r\n  ELSIF TG_OP = 'UPDATE' THEN\r\n    -- Detectar tipo de mudan√ßa\r\n    IF OLD.status != NEW.status THEN\r\n      v_tipo_evento := 'mudanca_status';\r\n      v_descricao := 'Status alterado de \"' || OLD.status || '\" para \"' || NEW.status || '\"';\r\n      \r\n      INSERT INTO historico_ordem_servico (\r\n        id_ordem_servico,\r\n        tipo_evento,\r\n        status_anterior,\r\n        status_novo,\r\n        descricao,\r\n        dados_anteriores,\r\n        dados_novos,\r\n        criado_por,\r\n        criado_por_nome\r\n      ) VALUES (\r\n        NEW.id,\r\n        v_tipo_evento,\r\n        OLD.status,\r\n        NEW.status,\r\n        v_descricao,\r\n        to_jsonb(OLD),\r\n        to_jsonb(NEW),\r\n        NEW.atualizado_por,\r\n        v_usuario_nome\r\n      );\r\n    END IF;\r\n    \r\n    -- Registrar mudan√ßa de t√©cnico respons√°vel\r\n    IF COALESCE(OLD.tecnico_responsavel::TEXT, '') != COALESCE(NEW.tecnico_responsavel::TEXT, '') THEN\r\n      DECLARE\r\n        v_tecnico_nome VARCHAR(255);\r\n      BEGIN\r\n        IF NEW.tecnico_responsavel IS NOT NULL THEN\r\n          SELECT nome INTO v_tecnico_nome\r\n          FROM tecnicos\r\n          WHERE usuario_id = NEW.tecnico_responsavel\r\n          LIMIT 1;\r\n          \r\n          v_descricao := 'OS atribu√≠da ao t√©cnico: ' || COALESCE(v_tecnico_nome, 'T√©cnico n√£o identificado');\r\n        ELSE\r\n          v_descricao := 'T√©cnico respons√°vel removido';\r\n        END IF;\r\n        \r\n        INSERT INTO historico_ordem_servico (\r\n          id_ordem_servico,\r\n          tipo_evento,\r\n          descricao,\r\n          dados_anteriores,\r\n          dados_novos,\r\n          criado_por,\r\n          criado_por_nome\r\n        ) VALUES (\r\n          NEW.id,\r\n          'atribuicao_tecnico',\r\n          v_descricao,\r\n          jsonb_build_object('tecnico_responsavel', OLD.tecnico_responsavel),\r\n          jsonb_build_object('tecnico_responsavel', NEW.tecnico_responsavel),\r\n          NEW.atualizado_por,\r\n          v_usuario_nome\r\n        );\r\n      END;\r\n    END IF;\r\n    \r\n    -- Registrar mudan√ßa nas observa√ß√µes t√©cnicas\r\n    IF COALESCE(OLD.observacoes_tecnicas, '') != COALESCE(NEW.observacoes_tecnicas, '') THEN\r\n      INSERT INTO historico_ordem_servico (\r\n        id_ordem_servico,\r\n        tipo_evento,\r\n        descricao,\r\n        dados_anteriores,\r\n        dados_novos,\r\n        criado_por,\r\n        criado_por_nome\r\n      ) VALUES (\r\n        NEW.id,\r\n        'observacao',\r\n        'Observa√ß√µes t√©cnicas atualizadas',\r\n        jsonb_build_object('observacoes_tecnicas', OLD.observacoes_tecnicas),\r\n        jsonb_build_object('observacoes_tecnicas', NEW.observacoes_tecnicas),\r\n        NEW.atualizado_por,\r\n        v_usuario_nome\r\n      );\r\n    END IF;\r\n    \r\n    -- Registrar conclus√£o da OS\r\n    IF NEW.data_conclusao IS NOT NULL AND OLD.data_conclusao IS NULL THEN\r\n      INSERT INTO historico_ordem_servico (\r\n        id_ordem_servico,\r\n        tipo_evento,\r\n        descricao,\r\n        dados_novos,\r\n        criado_por,\r\n        criado_por_nome\r\n      ) VALUES (\r\n        NEW.id,\r\n        'conclusao',\r\n        'OS conclu√≠da pelo t√©cnico',\r\n        jsonb_build_object(\r\n          'data_conclusao', NEW.data_conclusao,\r\n          'observacoes_tecnicas', NEW.observacoes_tecnicas\r\n        ),\r\n        NEW.atualizado_por,\r\n        v_usuario_nome\r\n      );\r\n    END IF;\r\n    \r\n    -- Registrar outras mudan√ßas importantes de valores\r\n    IF OLD.valor_total != NEW.valor_total OR \r\n       OLD.valor_orcamento != NEW.valor_orcamento OR\r\n       OLD.valor_pago != NEW.valor_pago THEN\r\n      INSERT INTO historico_ordem_servico (\r\n        id_ordem_servico,\r\n        tipo_evento,\r\n        descricao,\r\n        dados_anteriores,\r\n        dados_novos,\r\n        criado_por,\r\n        criado_por_nome\r\n      ) VALUES (\r\n        NEW.id,\r\n        'atualizacao_valores',\r\n        'Valores atualizados',\r\n        jsonb_build_object(\r\n          'valor_orcamento', OLD.valor_orcamento,\r\n          'valor_total', OLD.valor_total,\r\n          'valor_pago', OLD.valor_pago,\r\n          'valor_desconto', OLD.valor_desconto\r\n        ),\r\n        jsonb_build_object(\r\n          'valor_orcamento', NEW.valor_orcamento,\r\n          'valor_total', NEW.valor_total,\r\n          'valor_pago', NEW.valor_pago,\r\n          'valor_desconto', NEW.valor_desconto\r\n        ),\r\n        NEW.atualizado_por,\r\n        v_usuario_nome\r\n      );\r\n    END IF;\r\n  END IF;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "ordem_servico",
    "trigger_nome": "trigger_lancamento_caixa_os",
    "funcao": "criar_lancamento_caixa_os",
    "definicao_completa": "CREATE TRIGGER trigger_lancamento_caixa_os AFTER UPDATE ON public.ordem_servico FOR EACH ROW EXECUTE FUNCTION criar_lancamento_caixa_os()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.criar_lancamento_caixa_os()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_total_pecas DECIMAL(10, 2);\r\n  v_valor_servico DECIMAL(10, 2);\r\nBEGIN\r\n  -- Apenas criar lan√ßamento se status mudou para 'entregue'\r\n  IF NEW.status = 'entregue' AND OLD.status != 'entregue' THEN\r\n    \r\n    -- Calcular total das pe√ßas\r\n    SELECT COALESCE(SUM(valor_total), 0) INTO v_total_pecas\r\n    FROM ordem_servico_pecas\r\n    WHERE id_ordem_servico = NEW.id;\r\n    \r\n    -- Calcular valor do servi√ßo (total - pe√ßas)\r\n    v_valor_servico := COALESCE(NEW.valor_total, 0) - v_total_pecas;\r\n    \r\n    -- Criar lan√ßamento no caixa (se n√£o existir)\r\n    INSERT INTO ordem_servico_caixa (\r\n      id_ordem_servico,\r\n      id_loja,\r\n      valor_total,\r\n      valor_pecas,\r\n      valor_servico,\r\n      valor_desconto,\r\n      status_caixa,\r\n      criado_por\r\n    )\r\n    SELECT\r\n      NEW.id,\r\n      NEW.id_loja,\r\n      COALESCE(NEW.valor_total, 0),\r\n      v_total_pecas,\r\n      v_valor_servico,\r\n      COALESCE(NEW.valor_desconto, 0),\r\n      'pendente',\r\n      NEW.atualizado_por\r\n    WHERE NOT EXISTS (\r\n      SELECT 1 FROM ordem_servico_caixa \r\n      WHERE id_ordem_servico = NEW.id\r\n    );\r\n    \r\n    -- Registrar no hist√≥rico\r\n    INSERT INTO historico_ordem_servico (\r\n      id_ordem_servico,\r\n      tipo_evento,\r\n      descricao,\r\n      criado_por\r\n    ) VALUES (\r\n      NEW.id,\r\n      'lancamento_caixa',\r\n      'Lan√ßamento criado no caixa - Valor: R$ ' || COALESCE(NEW.valor_total, 0),\r\n      NEW.atualizado_por\r\n    );\r\n  END IF;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "ordem_servico",
    "trigger_nome": "trigger_laudo_atualizado",
    "funcao": "registrar_laudo_atualizado",
    "definicao_completa": "CREATE TRIGGER trigger_laudo_atualizado AFTER UPDATE ON public.ordem_servico FOR EACH ROW WHEN (((new.laudo_diagnostico IS DISTINCT FROM old.laudo_diagnostico) OR (new.laudo_causa IS DISTINCT FROM old.laudo_causa) OR (new.laudo_procedimentos IS DISTINCT FROM old.laudo_procedimentos) OR (new.laudo_recomendacoes IS DISTINCT FROM old.laudo_recomendacoes) OR (new.laudo_garantia_dias IS DISTINCT FROM old.laudo_garantia_dias) OR (new.laudo_condicao_final IS DISTINCT FROM old.laudo_condicao_final))) EXECUTE FUNCTION registrar_laudo_atualizado()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.registrar_laudo_atualizado()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    mudancas text[];\r\n    evento text;\r\n    descr text;\r\n    v_usuario_nome text;\r\nBEGIN\r\n    mudancas := ARRAY[]::text[];\r\n    \r\n    -- Buscar nome do usu√°rio (ANTES do IF/ELSE)\r\n    SELECT nome INTO v_usuario_nome\r\n    FROM usuarios\r\n    WHERE id = auth.uid();\r\n    \r\n    -- Se n√£o encontrar, usar 'Sistema'\r\n    IF v_usuario_nome IS NULL THEN\r\n        v_usuario_nome := 'Sistema';\r\n    END IF;\r\n    \r\n    -- Verifica se √© preenchimento inicial ou atualiza√ß√£o\r\n    IF OLD.laudo_diagnostico IS NULL AND NEW.laudo_diagnostico IS NOT NULL THEN\r\n        evento := 'laudo_preenchido';\r\n        descr := 'Laudo t√©cnico preenchido';\r\n    ELSE\r\n        evento := 'laudo_atualizado';\r\n        \r\n        -- Identifica campos que mudaram\r\n        IF COALESCE(OLD.laudo_diagnostico, '') != COALESCE(NEW.laudo_diagnostico, '') THEN\r\n            mudancas := array_append(mudancas, 'Diagn√≥stico');\r\n        END IF;\r\n        \r\n        IF COALESCE(OLD.laudo_causa, '') != COALESCE(NEW.laudo_causa, '') THEN\r\n            mudancas := array_append(mudancas, 'Causa');\r\n        END IF;\r\n        \r\n        IF COALESCE(OLD.laudo_procedimentos, '') != COALESCE(NEW.laudo_procedimentos, '') THEN\r\n            mudancas := array_append(mudancas, 'Procedimentos');\r\n        END IF;\r\n        \r\n        IF COALESCE(OLD.laudo_recomendacoes, '') != COALESCE(NEW.laudo_recomendacoes, '') THEN\r\n            mudancas := array_append(mudancas, 'Recomenda√ß√µes');\r\n        END IF;\r\n        \r\n        IF COALESCE(OLD.laudo_condicao_final, '') != COALESCE(NEW.laudo_condicao_final, '') THEN\r\n            mudancas := array_append(mudancas, 'Condi√ß√£o Final');\r\n        END IF;\r\n        \r\n        IF OLD.laudo_garantia_dias IS DISTINCT FROM NEW.laudo_garantia_dias THEN\r\n            mudancas := array_append(mudancas, 'Garantia: ' || COALESCE(OLD.laudo_garantia_dias::text, 'NULL') || ' ‚Üí ' || COALESCE(NEW.laudo_garantia_dias::text, 'NULL') || ' dias');\r\n        END IF;\r\n        \r\n        descr := 'Laudo t√©cnico atualizado: ' || array_to_string(mudancas, ', ');\r\n    END IF;\r\n    \r\n    -- Se houve mudan√ßas relevantes, registra (AGORA USA VALUES AO INV√âS DE SELECT)\r\n    IF array_length(mudancas, 1) > 0 OR evento = 'laudo_preenchido' THEN\r\n        INSERT INTO historico_ordem_servico (\r\n            id_ordem_servico,\r\n            tipo_evento,\r\n            descricao,\r\n            dados_anteriores,\r\n            dados_novos,\r\n            criado_por,\r\n            criado_por_nome\r\n        ) VALUES (\r\n            NEW.id,\r\n            evento,\r\n            descr,\r\n            CASE \r\n                WHEN evento = 'laudo_atualizado' THEN\r\n                    jsonb_build_object(\r\n                        'diagnostico', OLD.laudo_diagnostico,\r\n                        'causa', OLD.laudo_causa,\r\n                        'procedimentos', OLD.laudo_procedimentos,\r\n                        'recomendacoes', OLD.laudo_recomendacoes,\r\n                        'garantia_dias', OLD.laudo_garantia_dias,\r\n                        'condicao_final', OLD.laudo_condicao_final\r\n                    )\r\n                ELSE NULL\r\n            END,\r\n            jsonb_build_object(\r\n                'diagnostico', NEW.laudo_diagnostico,\r\n                'causa', NEW.laudo_causa,\r\n                'procedimentos', NEW.laudo_procedimentos,\r\n                'recomendacoes', NEW.laudo_recomendacoes,\r\n                'garantia_dias', NEW.laudo_garantia_dias,\r\n                'condicao_final', NEW.laudo_condicao_final\r\n            ),\r\n            auth.uid(),\r\n            v_usuario_nome\r\n        );\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEXCEPTION WHEN OTHERS THEN\r\n    -- Log de erro (aparece nos logs do Supabase)\r\n    RAISE WARNING 'Erro no trigger registrar_laudo_atualizado: %', SQLERRM;\r\n    RETURN NEW; -- Continua mesmo com erro para n√£o bloquear o UPDATE\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "ordem_servico_fotos",
    "trigger_nome": "trigger_foto_adicionada",
    "funcao": "registrar_foto_adicionada",
    "definicao_completa": "CREATE TRIGGER trigger_foto_adicionada AFTER INSERT ON public.ordem_servico_fotos FOR EACH ROW EXECUTE FUNCTION registrar_foto_adicionada()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.registrar_foto_adicionada()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    INSERT INTO historico_ordem_servico (\r\n        id_ordem_servico,\r\n        tipo_evento,\r\n        descricao,\r\n        dados_novos,\r\n        criado_por,\r\n        criado_por_nome\r\n    )\r\n    SELECT \r\n        NEW.id_ordem_servico,\r\n        'foto_adicionada',\r\n        'Foto adicionada √† ordem de servi√ßo',\r\n        jsonb_build_object(\r\n            'foto_id', NEW.id,\r\n            'url', NEW.url,\r\n            'ordem', NEW.ordem,\r\n            'is_principal', NEW.is_principal\r\n        ),\r\n        auth.uid(),\r\n        u.nome\r\n    FROM usuarios u\r\n    WHERE u.id = auth.uid();\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "ordem_servico_fotos",
    "trigger_nome": "trigger_update_ordem_servico_fotos_timestamp",
    "funcao": "update_ordem_servico_fotos_updated_at",
    "definicao_completa": "CREATE TRIGGER trigger_update_ordem_servico_fotos_timestamp BEFORE UPDATE ON public.ordem_servico_fotos FOR EACH ROW EXECUTE FUNCTION update_ordem_servico_fotos_updated_at()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.update_ordem_servico_fotos_updated_at()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.atualizado_em = CURRENT_TIMESTAMP;\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "ordem_servico_fotos",
    "trigger_nome": "trigger_verificar_foto_principal_os",
    "funcao": "verificar_foto_principal_os",
    "definicao_completa": "CREATE TRIGGER trigger_verificar_foto_principal_os BEFORE INSERT OR UPDATE ON public.ordem_servico_fotos FOR EACH ROW EXECUTE FUNCTION verificar_foto_principal_os()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.verificar_foto_principal_os()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Se est√° marcando como principal\r\n  IF NEW.is_principal = true THEN\r\n    -- Remove o flag principal de todas as outras fotos desta OS\r\n    UPDATE ordem_servico_fotos\r\n    SET is_principal = false\r\n    WHERE id_ordem_servico = NEW.id_ordem_servico\r\n      AND id != NEW.id;\r\n  END IF;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "ordem_servico_pagamentos",
    "trigger_nome": "trigger_atualizar_valor_pago_delete",
    "funcao": "atualizar_valor_pago_os",
    "definicao_completa": "CREATE TRIGGER trigger_atualizar_valor_pago_delete AFTER DELETE ON public.ordem_servico_pagamentos FOR EACH ROW EXECUTE FUNCTION atualizar_valor_pago_os()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.atualizar_valor_pago_os()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Atualiza o valor_pago da OS com a soma dos pagamentos\r\n  UPDATE ordem_servico\r\n  SET valor_pago = (\r\n    SELECT COALESCE(SUM(valor), 0)\r\n    FROM ordem_servico_pagamentos\r\n    WHERE id_ordem_servico = NEW.id_ordem_servico\r\n  )\r\n  WHERE id = NEW.id_ordem_servico;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "ordem_servico_pagamentos",
    "trigger_nome": "trigger_atualizar_valor_pago_insert",
    "funcao": "atualizar_valor_pago_os",
    "definicao_completa": "CREATE TRIGGER trigger_atualizar_valor_pago_insert AFTER INSERT ON public.ordem_servico_pagamentos FOR EACH ROW EXECUTE FUNCTION atualizar_valor_pago_os()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.atualizar_valor_pago_os()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Atualiza o valor_pago da OS com a soma dos pagamentos\r\n  UPDATE ordem_servico\r\n  SET valor_pago = (\r\n    SELECT COALESCE(SUM(valor), 0)\r\n    FROM ordem_servico_pagamentos\r\n    WHERE id_ordem_servico = NEW.id_ordem_servico\r\n  )\r\n  WHERE id = NEW.id_ordem_servico;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "ordem_servico_pagamentos",
    "trigger_nome": "trigger_atualizar_valor_pago_update",
    "funcao": "atualizar_valor_pago_os",
    "definicao_completa": "CREATE TRIGGER trigger_atualizar_valor_pago_update AFTER UPDATE ON public.ordem_servico_pagamentos FOR EACH ROW EXECUTE FUNCTION atualizar_valor_pago_os()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.atualizar_valor_pago_os()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  -- Atualiza o valor_pago da OS com a soma dos pagamentos\r\n  UPDATE ordem_servico\r\n  SET valor_pago = (\r\n    SELECT COALESCE(SUM(valor), 0)\r\n    FROM ordem_servico_pagamentos\r\n    WHERE id_ordem_servico = NEW.id_ordem_servico\r\n  )\r\n  WHERE id = NEW.id_ordem_servico;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "ordem_servico_pecas",
    "trigger_nome": "trigger_peca_adicionada",
    "funcao": "registrar_peca_adicionada",
    "definicao_completa": "CREATE TRIGGER trigger_peca_adicionada AFTER INSERT ON public.ordem_servico_pecas FOR EACH ROW EXECUTE FUNCTION registrar_peca_adicionada()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.registrar_peca_adicionada()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nBEGIN\r\n    INSERT INTO historico_ordem_servico (\r\n        id_ordem_servico,\r\n        tipo_evento,\r\n        descricao,\r\n        dados_novos,\r\n        criado_por,\r\n        criado_por_nome\r\n    )\r\n    SELECT \r\n        NEW.id_ordem_servico,\r\n        'peca_adicionada',\r\n        'Pe√ßa adicionada: ' || NEW.descricao_peca || ' (Qtd: ' || NEW.quantidade || ')',\r\n        jsonb_build_object(\r\n            'peca_id', NEW.id,\r\n            'descricao', NEW.descricao_peca,\r\n            'quantidade', NEW.quantidade,\r\n            'tipo_produto', NEW.tipo_produto,\r\n            'valor_venda', NEW.valor_venda,\r\n            'valor_total', NEW.valor_total\r\n        ),\r\n        auth.uid(),\r\n        u.nome\r\n    FROM usuarios u\r\n    WHERE u.id = auth.uid();\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "ordem_servico_pecas",
    "trigger_nome": "trigger_peca_atualizada",
    "funcao": "registrar_peca_atualizada",
    "definicao_completa": "CREATE TRIGGER trigger_peca_atualizada AFTER UPDATE ON public.ordem_servico_pecas FOR EACH ROW WHEN (((old.quantidade IS DISTINCT FROM new.quantidade) OR (old.valor_venda IS DISTINCT FROM new.valor_venda) OR (old.estoque_baixado IS DISTINCT FROM new.estoque_baixado))) EXECUTE FUNCTION registrar_peca_atualizada()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.registrar_peca_atualizada()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    mudancas text[];\r\nBEGIN\r\n    -- Verifica quais campos mudaram\r\n    mudancas := ARRAY[]::text[];\r\n    \r\n    IF OLD.quantidade != NEW.quantidade THEN\r\n        mudancas := array_append(mudancas, 'Quantidade: ' || OLD.quantidade || ' ‚Üí ' || NEW.quantidade);\r\n    END IF;\r\n    \r\n    IF OLD.valor_venda != NEW.valor_venda THEN\r\n        mudancas := array_append(mudancas, 'Valor: R$ ' || OLD.valor_venda || ' ‚Üí R$ ' || NEW.valor_venda);\r\n    END IF;\r\n    \r\n    IF OLD.estoque_baixado != NEW.estoque_baixado THEN\r\n        mudancas := array_append(mudancas, \r\n            CASE \r\n                WHEN NEW.estoque_baixado THEN 'Estoque baixado'\r\n                ELSE 'Baixa de estoque cancelada'\r\n            END\r\n        );\r\n    END IF;\r\n    \r\n    -- Se houve mudan√ßas, registra no hist√≥rico\r\n    IF array_length(mudancas, 1) > 0 THEN\r\n        INSERT INTO historico_ordem_servico (\r\n            id_ordem_servico,\r\n            tipo_evento,\r\n            descricao,\r\n            dados_anteriores,\r\n            dados_novos,\r\n            criado_por,\r\n            criado_por_nome\r\n        )\r\n        SELECT \r\n            NEW.id_ordem_servico,\r\n            'peca_atualizada',\r\n            'Pe√ßa atualizada: ' || NEW.descricao_peca || ' - ' || array_to_string(mudancas, ', '),\r\n            jsonb_build_object(\r\n                'peca_id', OLD.id,\r\n                'quantidade', OLD.quantidade,\r\n                'valor_venda', OLD.valor_venda,\r\n                'estoque_baixado', OLD.estoque_baixado\r\n            ),\r\n            jsonb_build_object(\r\n                'peca_id', NEW.id,\r\n                'quantidade', NEW.quantidade,\r\n                'valor_venda', NEW.valor_venda,\r\n                'estoque_baixado', NEW.estoque_baixado\r\n            ),\r\n            auth.uid(),\r\n            u.nome\r\n        FROM usuarios u\r\n        WHERE u.id = auth.uid();\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "permissoes",
    "trigger_nome": "trg_update_permissoes",
    "funcao": "update_timestamp",
    "definicao_completa": "CREATE TRIGGER trg_update_permissoes BEFORE UPDATE ON public.permissoes FOR EACH ROW EXECUTE FUNCTION update_timestamp()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.update_timestamp()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nbegin\r\n  new.atualizado_em = now();\r\n  return new;\r\nend;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "produtos",
    "trigger_nome": "trigger_atualizar_produtos",
    "funcao": "atualizar_timestamp_produtos",
    "definicao_completa": "CREATE TRIGGER trigger_atualizar_produtos BEFORE UPDATE ON public.produtos FOR EACH ROW EXECUTE FUNCTION atualizar_timestamp_produtos()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.atualizar_timestamp_produtos()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    -- A tabela produtos usa atualizado_em (n√£o updated_at)\r\n    NEW.atualizado_em = NOW();\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "produtos",
    "trigger_nome": "trigger_historico_produto",
    "funcao": "registrar_historico_produto",
    "definicao_completa": "CREATE TRIGGER trigger_historico_produto AFTER UPDATE ON public.produtos FOR EACH ROW EXECUTE FUNCTION registrar_historico_produto()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.registrar_historico_produto()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\r\nDECLARE\r\n    v_usuario_id UUID;\r\nBEGIN\r\n    -- Determinar o usu√°rio que fez a altera√ß√£o\r\n    v_usuario_id := COALESCE(NEW.atualizado_por, auth.uid());\r\n\r\n    -- Verificar altera√ß√£o em descri√ß√£o\r\n    IF OLD.descricao IS DISTINCT FROM NEW.descricao THEN\r\n        INSERT INTO historico_produtos (produto_id, campo, valor_antigo, valor_novo, usuario_id)\r\n        VALUES (NEW.id, 'descricao', OLD.descricao, NEW.descricao, v_usuario_id);\r\n    END IF;\r\n\r\n    -- Verificar altera√ß√£o em grupo\r\n    IF OLD.grupo IS DISTINCT FROM NEW.grupo THEN\r\n        INSERT INTO historico_produtos (produto_id, campo, valor_antigo, valor_novo, usuario_id)\r\n        VALUES (NEW.id, 'grupo', OLD.grupo, NEW.grupo, v_usuario_id);\r\n    END IF;\r\n\r\n    -- Verificar altera√ß√£o em categoria\r\n    IF OLD.categoria IS DISTINCT FROM NEW.categoria THEN\r\n        INSERT INTO historico_produtos (produto_id, campo, valor_antigo, valor_novo, usuario_id)\r\n        VALUES (NEW.id, 'categoria', OLD.categoria, NEW.categoria, v_usuario_id);\r\n    END IF;\r\n\r\n    -- Verificar altera√ß√£o em c√≥digo do fabricante\r\n    IF OLD.codigo_fabricante IS DISTINCT FROM NEW.codigo_fabricante THEN\r\n        INSERT INTO historico_produtos (produto_id, campo, valor_antigo, valor_novo, usuario_id)\r\n        VALUES (NEW.id, 'codigo_fabricante', OLD.codigo_fabricante, NEW.codigo_fabricante, v_usuario_id);\r\n    END IF;\r\n\r\n    -- Verificar altera√ß√£o em modelos\r\n    IF OLD.modelos IS DISTINCT FROM NEW.modelos THEN\r\n        INSERT INTO historico_produtos (produto_id, campo, valor_antigo, valor_novo, usuario_id)\r\n        VALUES (NEW.id, 'modelos', OLD.modelos, NEW.modelos, v_usuario_id);\r\n    END IF;\r\n\r\n    -- Verificar altera√ß√£o em marca\r\n    IF OLD.marca IS DISTINCT FROM NEW.marca THEN\r\n        INSERT INTO historico_produtos (produto_id, campo, valor_antigo, valor_novo, usuario_id)\r\n        VALUES (NEW.id, 'marca', OLD.marca, NEW.marca, v_usuario_id);\r\n    END IF;\r\n\r\n    -- Verificar altera√ß√£o em pre√ßo de compra\r\n    IF OLD.preco_compra IS DISTINCT FROM NEW.preco_compra THEN\r\n        INSERT INTO historico_produtos (produto_id, campo, valor_antigo, valor_novo, usuario_id)\r\n        VALUES (NEW.id, 'preco_compra', OLD.preco_compra::TEXT, NEW.preco_compra::TEXT, v_usuario_id);\r\n    END IF;\r\n\r\n    -- Verificar altera√ß√£o em pre√ßo de venda\r\n    IF OLD.preco_venda IS DISTINCT FROM NEW.preco_venda THEN\r\n        INSERT INTO historico_produtos (produto_id, campo, valor_antigo, valor_novo, usuario_id)\r\n        VALUES (NEW.id, 'preco_venda', OLD.preco_venda::TEXT, NEW.preco_venda::TEXT, v_usuario_id);\r\n    END IF;\r\n\r\n    -- Verificar altera√ß√£o em quantidade m√≠nima\r\n    IF OLD.quantidade_minima IS DISTINCT FROM NEW.quantidade_minima THEN\r\n        INSERT INTO historico_produtos (produto_id, campo, valor_antigo, valor_novo, usuario_id)\r\n        VALUES (NEW.id, 'quantidade_minima', OLD.quantidade_minima::TEXT, NEW.quantidade_minima::TEXT, v_usuario_id);\r\n    END IF;\r\n\r\n    -- Verificar altera√ß√£o em ativo\r\n    IF OLD.ativo IS DISTINCT FROM NEW.ativo THEN\r\n        INSERT INTO historico_produtos (produto_id, campo, valor_antigo, valor_novo, usuario_id)\r\n        VALUES (NEW.id, 'ativo', OLD.ativo::TEXT, NEW.ativo::TEXT, v_usuario_id);\r\n    END IF;\r\n\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "produtos_fornecedores",
    "trigger_nome": "trigger_atualizar_timestamp_produtos_fornecedores",
    "funcao": "atualizar_timestamp_produtos_fornecedores",
    "definicao_completa": "CREATE TRIGGER trigger_atualizar_timestamp_produtos_fornecedores BEFORE UPDATE ON public.produtos_fornecedores FOR EACH ROW EXECUTE FUNCTION atualizar_timestamp_produtos_fornecedores()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.atualizar_timestamp_produtos_fornecedores()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    NEW.atualizado_em = NOW();\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "quebra_pecas",
    "trigger_nome": "trigger_processar_quebra",
    "funcao": "processar_quebra_peca",
    "definicao_completa": "CREATE TRIGGER trigger_processar_quebra BEFORE UPDATE ON public.quebra_pecas FOR EACH ROW EXECUTE FUNCTION processar_quebra_peca()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.processar_quebra_peca()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nDECLARE\r\n  v_produto RECORD;\r\nBEGIN\r\n  -- S√≥ processar quando aprovado for alterado para TRUE\r\n  IF NEW.aprovado = TRUE AND (OLD.aprovado IS NULL OR OLD.aprovado = FALSE) THEN\r\n    \r\n    -- Buscar informa√ß√µes do produto\r\n    SELECT * INTO v_produto\r\n    FROM produtos\r\n    WHERE id = NEW.id_produto;\r\n    \r\n    -- Deduzir do estoque da loja\r\n    UPDATE estoque_lojas\r\n    SET quantidade = quantidade - NEW.quantidade\r\n    WHERE id_produto = NEW.id_produto\r\n      AND id_loja = NEW.id_loja;\r\n    \r\n    -- Registrar no hist√≥rico de estoque\r\n    INSERT INTO historico_estoque (\r\n      id_produto,\r\n      id_loja,\r\n      tipo_movimentacao,\r\n      quantidade,\r\n      quantidade_anterior,\r\n      quantidade_nova,\r\n      quantidade_alterada,\r\n      motivo,\r\n      observacao,\r\n      usuario_id,\r\n      id_ordem_servico\r\n    )\r\n    SELECT \r\n      NEW.id_produto,\r\n      NEW.id_loja,\r\n      'quebra',\r\n      NEW.quantidade,\r\n      el.quantidade + NEW.quantidade, -- quantidade antes da dedu√ß√£o\r\n      el.quantidade, -- quantidade ap√≥s dedu√ß√£o\r\n      -NEW.quantidade, -- quantidade alterada (negativo para sa√≠da)\r\n      CONCAT('Quebra aprovada - ', NEW.tipo_ocorrencia),\r\n      NEW.motivo,\r\n      NEW.aprovado_por,\r\n      NEW.id_ordem_servico\r\n    FROM estoque_lojas el\r\n    WHERE el.id_produto = NEW.id_produto\r\n      AND el.id_loja = NEW.id_loja;\r\n      \r\n  END IF;\r\n  \r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "quebra_pecas",
    "trigger_nome": "trigger_quebra_aprovada",
    "funcao": "registrar_quebra_aprovada",
    "definicao_completa": "CREATE TRIGGER trigger_quebra_aprovada AFTER UPDATE ON public.quebra_pecas FOR EACH ROW WHEN ((old.aprovado IS DISTINCT FROM new.aprovado)) EXECUTE FUNCTION registrar_quebra_aprovada()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.registrar_quebra_aprovada()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_usuario_nome text;\r\n    v_produto_nome text;\r\n    status_texto text;\r\n    evento text;\r\nBEGIN\r\n    -- S√≥ registra se o status de aprova√ß√£o mudou\r\n    IF OLD.aprovado IS DISTINCT FROM NEW.aprovado THEN\r\n        -- Buscar nome do usu√°rio que aprovou\r\n        IF NEW.aprovado_por IS NOT NULL THEN\r\n            SELECT nome INTO v_usuario_nome\r\n            FROM usuarios\r\n            WHERE id = NEW.aprovado_por;\r\n        END IF;\r\n        \r\n        IF v_usuario_nome IS NULL THEN\r\n            v_usuario_nome := 'Sistema';\r\n        END IF;\r\n        \r\n        -- Buscar nome do produto\r\n        IF NEW.id_produto IS NOT NULL THEN\r\n            SELECT descricao INTO v_produto_nome\r\n            FROM produtos\r\n            WHERE id = NEW.id_produto;\r\n        ELSE\r\n            -- Para pe√ßas externas\r\n            SELECT descricao_peca INTO v_produto_nome\r\n            FROM ordem_servico_pecas\r\n            WHERE id_ordem_servico = NEW.id_ordem_servico\r\n            LIMIT 1;\r\n            \r\n            IF v_produto_nome IS NULL THEN\r\n                v_produto_nome := 'Pe√ßa externa';\r\n            END IF;\r\n        END IF;\r\n        \r\n        -- Definir status e evento\r\n        IF NEW.aprovado THEN\r\n            status_texto := 'aprovada';\r\n            evento := 'quebra_aprovada';\r\n        ELSE\r\n            status_texto := 'reprovada';\r\n            evento := 'quebra_reprovada';\r\n        END IF;\r\n        \r\n        -- Inserir no hist√≥rico\r\n        INSERT INTO historico_ordem_servico (\r\n            id_ordem_servico,\r\n            tipo_evento,\r\n            descricao,\r\n            dados_anteriores,\r\n            dados_novos,\r\n            criado_por,\r\n            criado_por_nome\r\n        ) VALUES (\r\n            NEW.id_ordem_servico,\r\n            evento,\r\n            'Quebra ' || status_texto || ': ' || v_produto_nome || ' (Qtd: ' || NEW.quantidade || ')',\r\n            jsonb_build_object(\r\n                'quebra_id', OLD.id,\r\n                'aprovado', OLD.aprovado,\r\n                'aprovado_em', OLD.aprovado_em\r\n            ),\r\n            jsonb_build_object(\r\n                'quebra_id', NEW.id,\r\n                'produto_nome', v_produto_nome,\r\n                'quantidade', NEW.quantidade,\r\n                'aprovado', NEW.aprovado,\r\n                'aprovado_em', NEW.aprovado_em,\r\n                'aprovado_por', NEW.aprovado_por,\r\n                'observacao_aprovacao', NEW.observacao_aprovacao\r\n            ),\r\n            NEW.aprovado_por,\r\n            v_usuario_nome\r\n        );\r\n    END IF;\r\n    \r\n    RETURN NEW;\r\nEXCEPTION WHEN OTHERS THEN\r\n    RAISE WARNING 'Erro no trigger registrar_quebra_aprovada: %', SQLERRM;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "quebra_pecas",
    "trigger_nome": "trigger_quebra_registrada",
    "funcao": "registrar_quebra_registrada",
    "definicao_completa": "CREATE TRIGGER trigger_quebra_registrada AFTER INSERT ON public.quebra_pecas FOR EACH ROW EXECUTE FUNCTION registrar_quebra_registrada()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.registrar_quebra_registrada()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n    v_usuario_nome text;\r\n    v_produto_nome text;\r\nBEGIN\r\n    -- Buscar nome do t√©cnico que criou (campo criado_por na quebra_pecas)\r\n    IF NEW.criado_por IS NOT NULL THEN\r\n        -- Primeiro tenta buscar na tabela usuarios\r\n        SELECT nome INTO v_usuario_nome\r\n        FROM usuarios\r\n        WHERE id = NEW.criado_por;\r\n        \r\n        -- Se n√£o encontrar em usuarios, busca em tecnicos\r\n        IF v_usuario_nome IS NULL THEN\r\n            SELECT nome INTO v_usuario_nome\r\n            FROM tecnicos\r\n            WHERE usuario_id = NEW.criado_por;\r\n        END IF;\r\n    END IF;\r\n    \r\n    -- Se ainda n√£o encontrou, usa 'Sistema'\r\n    IF v_usuario_nome IS NULL THEN\r\n        v_usuario_nome := 'Sistema';\r\n    END IF;\r\n    \r\n    -- Buscar nome do produto (se existir - pode ser pe√ßa externa)\r\n    IF NEW.id_produto IS NOT NULL THEN\r\n        SELECT descricao INTO v_produto_nome\r\n        FROM produtos\r\n        WHERE id = NEW.id_produto;\r\n    ELSE\r\n        -- Para pe√ßas externas, buscar da ordem_servico_pecas\r\n        SELECT descricao_peca INTO v_produto_nome\r\n        FROM ordem_servico_pecas\r\n        WHERE id_ordem_servico = NEW.id_ordem_servico\r\n        LIMIT 1;\r\n        \r\n        IF v_produto_nome IS NULL THEN\r\n            v_produto_nome := 'Pe√ßa externa';\r\n        END IF;\r\n    END IF;\r\n    \r\n    -- Inserir no hist√≥rico\r\n    INSERT INTO historico_ordem_servico (\r\n        id_ordem_servico,\r\n        tipo_evento,\r\n        descricao,\r\n        dados_novos,\r\n        criado_por,\r\n        criado_por_nome\r\n    ) VALUES (\r\n        NEW.id_ordem_servico,\r\n        'quebra_registrada',\r\n        'Quebra registrada: ' || v_produto_nome || ' (Qtd: ' || NEW.quantidade || ') - ' || NEW.tipo_ocorrencia,\r\n        jsonb_build_object(\r\n            'quebra_id', NEW.id,\r\n            'produto_id', NEW.id_produto,\r\n            'produto_nome', v_produto_nome,\r\n            'quantidade', NEW.quantidade,\r\n            'tipo_ocorrencia', NEW.tipo_ocorrencia,\r\n            'motivo', NEW.motivo,\r\n            'responsavel', NEW.responsavel,\r\n            'descontar_tecnico', NEW.descontar_tecnico\r\n        ),\r\n        NEW.criado_por,\r\n        v_usuario_nome\r\n    );\r\n    \r\n    RETURN NEW;\r\nEXCEPTION WHEN OTHERS THEN\r\n    RAISE WARNING 'Erro no trigger registrar_quebra_registrada: %', SQLERRM;\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "rmas",
    "trigger_nome": "trigger_atualizar_timestamp_rma",
    "funcao": "atualizar_timestamp_rma",
    "definicao_completa": "CREATE TRIGGER trigger_atualizar_timestamp_rma BEFORE UPDATE ON public.rmas FOR EACH ROW EXECUTE FUNCTION atualizar_timestamp_rma()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.atualizar_timestamp_rma()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    NEW.atualizado_em = NOW();\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "tecnicos",
    "trigger_nome": "trigger_atualizar_tecnicos",
    "funcao": "atualizar_timestamp_tecnicos",
    "definicao_completa": "CREATE TRIGGER trigger_atualizar_tecnicos BEFORE UPDATE ON public.tecnicos FOR EACH ROW EXECUTE FUNCTION atualizar_timestamp_tecnicos()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.atualizar_timestamp_tecnicos()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n  NEW.atualizado_em = NOW();\r\n  RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "schema": "public",
    "tabela": "usuarios",
    "trigger_nome": "trg_auditoria_usuarios",
    "funcao": "fn_registrar_mudancas_usuario",
    "definicao_completa": "CREATE TRIGGER trg_auditoria_usuarios AFTER INSERT OR DELETE OR UPDATE ON public.usuarios FOR EACH ROW EXECUTE FUNCTION fn_registrar_mudancas_usuario()",
    "codigo_funcao": "CREATE OR REPLACE FUNCTION public.fn_registrar_mudancas_usuario()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\r\nDECLARE\r\n  v_usuario_atual UUID;\r\nBEGIN\r\n  -- Obt√©m o ID do usu√°rio autenticado\r\n  v_usuario_atual := auth.uid();\r\n\r\n  -- Opera√ß√£o INSERT\r\n  IF (TG_OP = 'INSERT') THEN\r\n    INSERT INTO public.historico_usuarios (\r\n      usuario_id,\r\n      usuario_alterou_id,\r\n      campo_alterado,\r\n      valor_anterior,\r\n      valor_novo,\r\n      tipo_operacao\r\n    ) VALUES (\r\n      NEW.id,\r\n      v_usuario_atual,\r\n      'criacao',\r\n      NULL,\r\n      'Usu√°rio criado',\r\n      'INSERT'\r\n    );\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  -- Opera√ß√£o UPDATE\r\n  IF (TG_OP = 'UPDATE') THEN\r\n    -- Verificar campo: nome\r\n    IF (OLD.nome IS DISTINCT FROM NEW.nome) THEN\r\n      INSERT INTO public.historico_usuarios (\r\n        usuario_id,\r\n        usuario_alterou_id,\r\n        campo_alterado,\r\n        valor_anterior,\r\n        valor_novo,\r\n        tipo_operacao\r\n      ) VALUES (\r\n        NEW.id,\r\n        v_usuario_atual,\r\n        'nome',\r\n        OLD.nome,\r\n        NEW.nome,\r\n        'UPDATE'\r\n      );\r\n    END IF;\r\n\r\n    -- Verificar campo: email\r\n    IF (OLD.email IS DISTINCT FROM NEW.email) THEN\r\n      INSERT INTO public.historico_usuarios (\r\n        usuario_id,\r\n        usuario_alterou_id,\r\n        campo_alterado,\r\n        valor_anterior,\r\n        valor_novo,\r\n        tipo_operacao\r\n      ) VALUES (\r\n        NEW.id,\r\n        v_usuario_atual,\r\n        'email',\r\n        OLD.email,\r\n        NEW.email,\r\n        'UPDATE'\r\n      );\r\n    END IF;\r\n\r\n    -- Verificar campo: telefone\r\n    IF (OLD.telefone IS DISTINCT FROM NEW.telefone) THEN\r\n      INSERT INTO public.historico_usuarios (\r\n        usuario_id,\r\n        usuario_alterou_id,\r\n        campo_alterado,\r\n        valor_anterior,\r\n        valor_novo,\r\n        tipo_operacao\r\n      ) VALUES (\r\n        NEW.id,\r\n        v_usuario_atual,\r\n        'telefone',\r\n        OLD.telefone,\r\n        NEW.telefone,\r\n        'UPDATE'\r\n      );\r\n    END IF;\r\n\r\n    -- Verificar campo: cpf\r\n    IF (OLD.cpf IS DISTINCT FROM NEW.cpf) THEN\r\n      INSERT INTO public.historico_usuarios (\r\n        usuario_id,\r\n        usuario_alterou_id,\r\n        campo_alterado,\r\n        valor_anterior,\r\n        valor_novo,\r\n        tipo_operacao\r\n      ) VALUES (\r\n        NEW.id,\r\n        v_usuario_atual,\r\n        'cpf',\r\n        OLD.cpf,\r\n        NEW.cpf,\r\n        'UPDATE'\r\n      );\r\n    END IF;\r\n\r\n    -- Verificar campo: ativo\r\n    IF (OLD.ativo IS DISTINCT FROM NEW.ativo) THEN\r\n      INSERT INTO public.historico_usuarios (\r\n        usuario_id,\r\n        usuario_alterou_id,\r\n        campo_alterado,\r\n        valor_anterior,\r\n        valor_novo,\r\n        tipo_operacao\r\n      ) VALUES (\r\n        NEW.id,\r\n        v_usuario_atual,\r\n        'status',\r\n        CASE WHEN OLD.ativo THEN 'Ativo' ELSE 'Inativo' END,\r\n        CASE WHEN NEW.ativo THEN 'Ativo' ELSE 'Inativo' END,\r\n        'UPDATE'\r\n      );\r\n    END IF;\r\n\r\n    RETURN NEW;\r\n  END IF;\r\n\r\n  -- Opera√ß√£o DELETE\r\n  IF (TG_OP = 'DELETE') THEN\r\n    INSERT INTO public.historico_usuarios (\r\n      usuario_id,\r\n      usuario_alterou_id,\r\n      campo_alterado,\r\n      valor_anterior,\r\n      valor_novo,\r\n      tipo_operacao\r\n    ) VALUES (\r\n      OLD.id,\r\n      v_usuario_atual,\r\n      'exclusao',\r\n      'Usu√°rio existente',\r\n      NULL,\r\n      'DELETE'\r\n    );\r\n    RETURN OLD;\r\n  END IF;\r\n\r\n  RETURN NULL;\r\nEND;\r\n$function$\n"
  }
]
